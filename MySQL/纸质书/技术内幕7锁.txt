1lock和latch
  latch：一般称为轻量锁,因为其要求锁定的时间必须非常短,若持续的时间长,则应用的性能会非常差
         在InnoDB存储引擎中,latch可以分为mutex(互斥量)和rwlock(读写锁)
         目的是用来保证并发线程操作临界资源的正确性,并且通常没有死锁检测的机制
         可以通过show engine innodb mutex;
  lock:其对象是事务,用来锁定的数据库中的对象,如表、页、行 ##
       并且一般lock的对象仅在事务commit或rollback后释放(不同事务隔离级别释放的时间可能不同)
       此外,lock是有死锁机制的
       可以通过：show engine innodb status\G;
                select * from information_schema.innodb_trx\G;
                select * from information_schema.innodb_locks\G;
                select * from information_schema.innodb_lock_waits\G;...
                show tables like ''

2InnoDB存储引擎层的锁
  InnoDB存储引擎实现了如下两种标准的行级锁：
  共享锁(S):允许事务读一行数据(lock in share mode)
  排他锁(X):允许事务删除或更新一行数据(for update)
  X锁与X,S都不兼容,S锁仅和S锁兼容,特别需要注意的是,因为两者都是行锁,兼容指的是同一记录(row)锁的兼容性情况

  此外,InnoDB存储引擎支持多粒度(granular)锁定,这种锁定允许事务在行级上的锁和表级上的锁同时存在(允许行锁和表锁共存)

  next-key locks
  record locks
  gap locks

  意向锁：InnoDB存储引擎支持意向锁比较简练,其意向锁是表级别的锁
         设计目的：为了在下一个事务中揭示下一行将被请求的锁类型
  类别：
      意向共享锁(IS):事务想要获取一张表中某几行的共享锁
      意向排他锁(IX):事务想要获取一张表中某几行的排他锁

  由于InnoDB存储引擎支持的是行级别的锁,因此意向锁其实不会阻塞除全表扫描以外的任何请求
  表级意向锁与行级锁的兼容性见 5.7基础视频\6MySQL锁：锁模式的兼容性.jpg

3一致性非锁定读
  一致性非锁定读是指InnoDB存储引擎通过行多版本控制的方式来读取当前执行时间数据库中行的数据,如果读取的行正在执行delete或update操作,这时读取操作不会去等待行上锁的释放
  相反的,InnoDB存储引擎会去读取行的一个快照数据

  之所以称之为非锁定读,因为不需要等到方位的行上X锁的释放,快照数据是指该行的之前版本的数据,该实现是通过undo段来完成

  undo用来在事务中回滚数据,因此快照读数据本身是没有额外的开销,而且读取快照数据是不需要上锁的,因为没有事务需要对历史的数据进行修改操作

  快照数据其实就是当前行数据之前的历史版本,每行记录可能有多个版本,也就是说每行记录可能有多个快照数据,一般称这种技术为行多版本技术,由此带来的并发控制,称为多版本并发控制

4自增长和锁
  在InnoDB存储引擎的内存结构中,对每个含有自增长值的表都有一个自增长计数器,当对含有自增长的计数器的表进行插入操作时,这个计数器会被初始化,通过执行select max(auto_inc_col) from t for update;来得到计数器的值

  插入操作会依据这个自增长的计数器加1赋予自增长列,这个实现方式称为AUTO-INC Locking,这种锁其实是采用一种特殊的表锁机制,为了提高插入的性能,锁不是在一个事务完成后才释放,而是在完成自增长直插入的SQL语句后立刻释放

  5.1.22开始,InnoDB存储引擎中提供了一种轻量级互斥量的自增长实现机制,这种机制大大提高了自增长插入的性能,innodb_autoinc_lock_mode(默认1)
  
  在InnoDB存储引擎中,自增长值的列必须是索引,同时必须是索引的第一个列

5锁的算法
  InnoDB存储引擎有3中行锁算法,分别是
    Record Lock:单个行记录上的锁
    Gap Lock:间隙锁,锁定一个范围,但不包含记录本身  gap锁的目的：是为了防止同一事物的两次当前读,出现幻读的情况
    Next-key Lock:Record Lock+Gap Lock,锁定一个范围,并且锁定记录本身     目的是解决幻读的问题