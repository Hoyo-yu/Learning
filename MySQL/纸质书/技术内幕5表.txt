1索引组织表
  在InnoDB存储引擎中,表都是根据主键顺序组织存放的,这种存储方式的表称为索引组织表,在InnoDB存储引擎中,每张表都有主键.
  显式的说明哪个是主键
  非空的唯一索引(第一个先定义的唯一索引)
  ROWID(6字节,当上面两种都没有的情况下)

  可以通过select _rowid from table_name;来查看哪个是主键,但对于多列组成的主键看不了

2InnoDB逻辑存储结构
  从InnoDB存储引擎的逻辑存储结构看,所有数据都被逻辑地存放在一个空间中,称之为表空间(tablespace).
  表空间又由段、区、页(块)组成
  表空间可以看做是InnoDB存储引擎逻辑结构的最高层,所有的数据都是存放在表空间中.
  默认情况下InnoDB存储引擎将所有数据存放在共享表空间中,如果用户启用了innodb_file_per_table这个参数,则每张表内的数据可以单独放在一个表空间内.
  如果启用了这个参数,每张表的表空间存放的只是数据、索引和插入缓冲Bitmap页,如回滚(undo)信息,插入缓冲索引页、系统事务信息,二次写缓冲等还是存放在原来的共享表空间中
  所以即使启用了这个参数,共享表空间还是会不断增大的
  可以通过py_innodb_page_info.py来查看表空间的页的情况,https://github.com/happieme/py_innodb_page_info

3段
  表空间是由各个段组成的,常见的段有数据段、索引段、回滚段等
  InnoDB存储引擎表时索引组织的,因此数据即索引,索引即数据;那么数据段即为B+树的叶子节点,索引段即为B+树的非索引节点
  在InnoDB存储引擎中,对段的管理都是由引擎自身所完成的

4区
  区是连续页组成的空间,在任何情况下每个区的大小都为1MB,为了保证区中页的连续性,InnoDB一次从磁盘申请4-5个区
  在默认的情况下,InnoDB存储引擎页的大小为16K,即一个区中有64个连续的页
  启用innodb_file_per_table这个参数后,创建的表的默认大小是96K,为什么至少不是1MB,因为在每个段开始时,先用32个页大小的碎片页来存放数据,在使用完这些页后才是64个连续页的申请,
  这样做的目的是,对于一些小表,或者是undo这类的段,可以在开始时申请较少的空间,节省磁盘空间容量的开销

  已经用完了32个碎片页,新的页会采用区的方式进行空间的申请

5页(块)
  同大部分数据库一样,InnoDB有页的概念,页是InnoDB磁盘管理的最小单位,可以通过参数innodb_page_size将页的大小进行修改,若设置完成,不可以对其进行修改,除非通过mysqldump导入和导出操作来产生新的库
  在InnoDB存储引擎中,常见的页类型有：
  数据页、undo页、系统页、事务数据页、插入缓冲位图页、插入缓冲空闲列表页、未压缩的二进制大对象页、压缩的二进制大对象页

6行
  InnoDB存储引擎是面向列的,也就是说数据是按行进行存放的,每个页存放的行记录是有硬性定义的,最多允许存放16KB/2-200行的记录,即7992行

7InnoDB行记录格式
  可以通过show table status like 'table_name';来查看该表的行记录格式
  Compact(mysql5.0后)行记录格式：不管是char还是varchar类型,在compact格式下NULL值都不占用任何存储空间
  Redundant(mysql5.0前)行记录格式：char类型将会占用可能存放的最大值字节数
  
  Compressed行记录格式和Dynamic行记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式,在数据页中只存放20个字节指向off page的指针,实际的数据都存放在Off page中

  Compressed行记录格式的另一个功能就是,存储在其中的行数据会以zlib的算法进行压缩,因此对于BLOB、TEXT、VARCHAR这类大长度类型的数据能够进行非常有效的存储

8行溢出数据？？
  InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外
  一般认为BLOB、LOB这类的大对象列类型的存储会把数据存放在数据页面之外,但不完全是,BLOB可以不讲数据放在溢出页面,而且即便是varchar列数据类型,依然有可能被存放为行溢出数据
  Oracle varchar最大存放4000字节、SQL server最大存放8000字节、MySQL的varchar类型可以存放65535字节
  latin1     一个字符1个字节      最大存储varchar的字符数为65532
  GBK        一个字符2个字节      最大存储varchar的字符数为32766
  UTF8       一个字符3个字节      最大存储varchar的字符数为21844
  
  MySQL官方手册中定义的65535长度是指所有varchar列的长度总和,如果列的长度总和超过这个长度,依然无法创建
  一个页存储的数据长度是16K=16*1024=16384字节,因此页中只能存放一条行记录是不行的,InnoDB存储引擎会自动将行数据存放在溢出页中
  如果可以在一个页中至少存放两行数据,那varchar类型的行数据就不会存放在BLOB页中,经测试发现,这个阈值的长度为8098(所有varchar列的长度总和)

  在大多数的情况下BLOB的行数据还是会发生行溢出,实际数据保存在BLOB页中,数据页只保存数据的768个前缀字节

9char的行结构存储
  从MySQL4.1起,char(N)中的N指的是字符的长度,不是字节长度,也就是不同的字符集下,char类型内部存储的可能不是定长的数据
  在UTF8下char(10)最小可以存储10字节的字符,最大可以存储30字节的字符,在某种程度上可以认为多字节字符编码的char类型的存储,InnoDB存储引擎在内部将视为变长字符类型

10InnoDB数据页结构
  **InnoDB存储引擎表总是B+数索引组织的

11约束
  为了保证数据的完整性,对于InnoDB而言,提供了这几种约束：Primary Key,Unique Key,Foreign Key,Default,NOT NULL
  约束的创建可以采用两种方式：表建立时就进行约束定义,利用alter table命令来创建约束
  查看某表的约束select constraint_name,constraint_type from information_schema.table_constraints where table_schema='test_db' and table_name='t2';
  和索引的区别：
             约束是一个逻辑的概念,用来保证数据的完整性;而索引就是一个数据结构,既有逻辑上的概念,在数据库中还代表着物理存储的方式
  
  对错误数据的约束：在某些默认的设置下,MySQL数据库允许非法的或不正确的数据的插入或更新,又或者可以在数据库内部将其转化成一个合法的值
                  如果用户想通过约束对于数据库非法数据的插入或更新,即MySQL数据库提示报错而不是警告,那么用户必须设置参数sql_mode,用来严格审核输入的参数

  enum约束和set约束：
                   MySQL数据库不支持传统的check约束,但是通过enum和set类型可以解决部分这样的约束,例如有一个性别类型,规定域的范围只能是male或female
                   在这种情况下用户可以通过enum类型加set sql_mode来进行约束

12触发器和约束
  用户已经知道完整性约束通常也可以使用触发器来实现,触发器的作用是在执行insert、delete和update命令前或之后自动调用SQL命令和存储过程(mysql5.1开始触发器已经相对稳定)
  创建触发器的命令是create trigger,只用具备super权限的MySQL用户才可以执行这条命令
  最多可以为一个表建立6个触发器(insert、delete、update) * (before、after)
  通过触发器,用户可以实现MySQL数据库本身并不支持的一些特性,如对于传统check约束的支持,物化视图、高级复制、审计等特性

13视图
  在MySQL数据库中,视图(View)是一个命名的虚表,它由一个SQL查询来定义,可以当做表使用
  与持久表不同的是,视图中的数据没有实际的物理存储
  视图的作用：
            视图在数据库中发挥着重要的作用,视图的主要用途之一是被用作一个抽象装置,特别是对于一些应用程序,程序本身不需要关心基表的结构,只需要按照视图定义来取数据或更新数据
            因此,视图同时在一定程度上起到一个安全层的作用

14分区表
  可通过show plugins;查看是否支持分区功能
  分区功能(5.1)并不是在存储引擎层完成的,因此不是只有InnoDB存储引擎支持分区,常见的MyISAM、NDB等都支持,CSV、FEDORATED、MERGE等不支持
  分区的过程是将一个表或索引分解为多个更小、更可管理的部分
  MySQL数据库支持的分区类型为水平分区,并不支持垂直分区？

  当前MySQL数据库支持以下几种类型的分区：
  RANGE分区(5.5)：行数据基于一个给定连续区间的列值被放入分区
  LIST分区(5.5)：和RANGE分区类型相似,只是LIST分区面向的是离散的值
  HASH分区：根据用户自定义的表达式的返回值来进行分区,返回值不能为负数
  KEY分区：根据MySQL数据库提供的哈希函数来进行分区